package com.iitb.gise;

import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.PriorityQueue;
import java.util.Set;

public class CCRPWithReuse1 {

	public static int runNo = 1;
	private Graph graph = new Graph();
	private Set<Node> PQAdditionList = new LinkedHashSet<Node>();
	private static double humanWalkingSpeed = 1.5;			//in m/s
	private int pathId = 1;
	private ArrayList<Route> pathList = new ArrayList<Route>();
	private Set<String> distinctRoutes = new LinkedHashSet<String>();
	
	public Set<String> getDistinctRoutes() {
		return distinctRoutes;
	}

	public void setDistinctRoutes(Set<String> distinctRoutes) {
		this.distinctRoutes = distinctRoutes;
	}

	public int getPathId() {
		return pathId;
	}

	public void setPathId(int pathId) {
		this.pathId = pathId;
	}

	public ArrayList<Route> getPathList() {
		return pathList;
	}

	public void setPathList(ArrayList<Route> pathList) {
		this.pathList = pathList;
	}

	public Set<Node> getPQAdditionList() {
		return PQAdditionList;
	}

	public void setPQAdditionList(Set<Node> pQAdditionList) {
		PQAdditionList = pQAdditionList;
	}

	public static double getHumanWalkingSpeed() {
		return humanWalkingSpeed;
	}

	public static void setHumanWalkingSpeed(double humanWalkingSpeed) {
		CCRPWithReuse1.humanWalkingSpeed = humanWalkingSpeed;
	}

	public Graph getGraph() {
		return graph;
	}

	public void setGraph(Graph graph) {
		this.graph = graph;
	}

	//finding the vertex by name
	public Node getNode(String nodeName) {
		Iterator<Node> it = this.getGraph().getNodeList().iterator();
		while (it.hasNext()) 
		{
			// System.out.println("getNode : 1");
			Node temp = it.next();
			if (temp.getNodeName().equals(nodeName))
				return temp;
		}
		return null;
	}
	
	public void addNodeToGraph(String nodeId, String nodeName, double x, double y, 
			int maxCapacity, int initialOccupancy, int nodeType)
	{
		Node node = new Node();
		node.setNodeId(nodeId);
		node.setNodeName(nodeName);
		node.setX(x);
		node.setY(y);
		node.setMaxCapacity(maxCapacity);
		node.setInitialOccupancy(initialOccupancy);
		node.setCurrentOccupancy(initialOccupancy);
		node.setNodeType(nodeType);
		node.setAdjacencies(null);
		node.setAdjacentScannedList(null);
		node.setParent(null);
		node.setPathUptoPreviousNode(null);
		node.setScanned(false);
		node.setChildList(null);
		if(nodeType == Node.DESTINATION)
			node.setMaxCapacity(Integer.MAX_VALUE);
		if(nodeType == Node.SOURCE)
			node.setTravelTime(0);
		else
			node.setTravelTime(Double.MAX_VALUE);
		ArrayList<Integer> nodeCapacityAtTime = new ArrayList<Integer>();
		nodeCapacityAtTime.add(node.getMaxCapacity());
		node.setNodeCapacityAtTime(nodeCapacityAtTime);
		this.getGraph().addNode(node);
	}
	
	public void addNodeToGraph(String nodeId, String nodeName, 
			int maxCapacity, int initialOccupancy, int nodeType)
	{
		Node node = new Node();
		node.setNodeId(nodeId);
		node.setNodeName(nodeName);
		node.setMaxCapacity(maxCapacity);
		node.setInitialOccupancy(initialOccupancy);
		node.setCurrentOccupancy(initialOccupancy);
		node.setNodeType(nodeType);
		node.setAdjacencies(null);
		node.setAdjacentScannedList(null);
		node.setParent(null);
		node.setPathUptoPreviousNode(null);
		node.setScanned(false);
		node.setChildList(null);
		if(nodeType == Node.DESTINATION)
			node.setMaxCapacity(Integer.MAX_VALUE);
		if(nodeType == Node.SOURCE)
			node.setTravelTime(0);
		else
			node.setTravelTime(Double.MAX_VALUE);
		ArrayList<Integer> nodeCapacityAtTime = new ArrayList<Integer>();
		nodeCapacityAtTime.add(node.getMaxCapacity());
		node.setNodeCapacityAtTime(nodeCapacityAtTime);
		this.getGraph().addNode(node);
	}
	
	public void addEdgeToGraph(int edgeID, String edgeName, String sourceName, 
			String targetName, int maxIntakeCapacity)
	{
		Edge edge = new Edge();
		edge.setEdgeID(edgeID);
		edge.setEdgeName(edgeName);
		edge.setMaxIntakeCapacity(maxIntakeCapacity);
		Node src = this.getNode(sourceName);
		Node target = this.getNode(targetName);
		int travelTime = (int) Math.ceil(Node.calculateDistance(src, target)/humanWalkingSpeed);
		edge.setTravelTime(travelTime);
		edge.setSource(src);
		edge.setTarget(target);
		
		EdgeCapacityAtThisTime edgeCapacityAtThisTime = new EdgeCapacityAtThisTime();
		edge.setEdgeCapacity(new ArrayList<Integer>());
		//For each section of edge, initially(t=0) capacity is its maximum
		for (int i = 0; i < travelTime; i++)
		{
			edgeCapacityAtThisTime.getCapacityOfSection().add(maxIntakeCapacity);
			edge.getEdgeCapacity().add(maxIntakeCapacity);
		}
		
		edge.addEdgeCapacityAtNextTimeInstance(edgeCapacityAtThisTime);
		EdgeCapacityAtThisTime edgeMaxCapacityTime = new EdgeCapacityAtThisTime(edgeCapacityAtThisTime);
		edge.setEdgeMaxCapacityTimeInstance(edgeMaxCapacityTime);
		graph.addEdge(edge);
		
		src.addAdjacentEdge(edge);
		target.addAdjacentEdge(edge);
	}
	
	public void addEdgeToGraph(int edgeID, String edgeName, String sourceName, 
			String targetName, int maxIntakeCapacity, int travelTime)
	{
		Edge edge = new Edge();
		edge.setEdgeID(edgeID);
		edge.setEdgeName(edgeName);
		edge.setMaxIntakeCapacity(maxIntakeCapacity);
		Node src = this.getNode(sourceName);
		Node target = this.getNode(targetName);
		edge.setTravelTime(travelTime);
		edge.setSource(src);
		edge.setTarget(target);
		
		EdgeCapacityAtThisTime edgeCapacityAtThisTime = new EdgeCapacityAtThisTime();
		edge.setEdgeCapacity(new ArrayList<Integer>());
		//For each section of edge, initially(t=0) capacity is its maximum
		for (int i = 0; i < travelTime; i++)
		{
			edgeCapacityAtThisTime.getCapacityOfSection().add(maxIntakeCapacity);
			edge.getEdgeCapacity().add(maxIntakeCapacity);
		}
		
		edge.addEdgeCapacityAtNextTimeInstance(edgeCapacityAtThisTime);
		EdgeCapacityAtThisTime edgeMaxCapacityTime = new EdgeCapacityAtThisTime(edgeCapacityAtThisTime);
		edge.setEdgeMaxCapacityTimeInstance(edgeMaxCapacityTime);
		graph.addEdge(edge);
		//System.out.println(edge.getEdgeID());
		src.addAdjacentEdge(edge);
		target.addAdjacentEdge(edge);
	}
	
	public void addEdgeToGraph(int edgeID, String edgeName, String sourceName, 
			String targetName, int maxIntakeCapacity, int travelTime, int x)
	{
		Edge edge = new Edge();
		edge.setEdgeID(edgeID);
		edge.setEdgeName(edgeName);
		edge.setMaxIntakeCapacity(maxIntakeCapacity);
		Node src = this.getNode(sourceName);
		Node target = this.getNode(targetName);
		edge.setTravelTime(travelTime);
		edge.setSource(src);
		edge.setTarget(target);
		
		EdgeCapacityAtThisTime edgeCapacityAtThisTime = new EdgeCapacityAtThisTime();
		edge.setEdgeCapacity(new ArrayList<Integer>());
		//For each section of edge, initially(t=0) capacity is its maximum
		for (int i = 0; i < travelTime; i++)
		{
			edgeCapacityAtThisTime.getCapacityOfSection().add(maxIntakeCapacity);
			edge.getEdgeCapacity().add(maxIntakeCapacity);
		}
		
		edge.addEdgeCapacityAtNextTimeInstance(edgeCapacityAtThisTime);
		EdgeCapacityAtThisTime edgeMaxCapacityTime = new EdgeCapacityAtThisTime(edgeCapacityAtThisTime);
		edge.setEdgeMaxCapacityTimeInstance(edgeMaxCapacityTime);
		graph.addEdge(edge);
		
		src.addAdjacentEdge(edge);
		//target.addAdjacentEdge(edge);
	}
	
	public void modifiedCCRPEvacuationPlanner()
	{
		PriorityQueue<Node> priorityQueue = new PriorityQueue<Node>();
		int evacueeCount = 0;
		int evacuationTime = 0;
		boolean sameTime = false;
		for(int index = 0;index<graph.getNodeList().size();index++)
		{
			Node node = graph.getNodeList().get(index);
			if(node.getNodeType() == Node.SOURCE)
			{
				//Add source list to priority queue
				priorityQueue.add(node);
				//count people
				evacueeCount = evacueeCount + node.getInitialOccupancy();
				
			}
		}
		//System.out.println(evacueeCount);
		//System.out.println(priorityQueue.size());
		int tempcount = 0;
		//while there are people in any source node
		while(evacueeCount > 0)
		{
			Node u = priorityQueue.poll();
			
			//while u is not a destination
			while(u.getNodeType() != Node.DESTINATION)
			{
				//System.out.println(u.getNodeName());
				//for all adjacent vertices of u
				for(int index = 0; index < u.getAdjacencies().size(); index++)
				{
					Edge edge = u.getAdjacencies().get(index);
					Node v;
					if(edge.getSource() == u)
						v = edge.getTarget();
					else
						v = edge.getSource();
					//System.out.println(u.getNodeName() + "---" + v.getNodeName());
					
					if (v.isScanned())
					{
						if(v.getParent() == u || u.getParent() == v)
						{
							//Do Nothing
						}
						else
						{
							u.addAdjacentScannedEdge(v);
							v.addAdjacentScannedEdge(u);
						}
					}
					else
					{
						simpleDijkstra(u, v, edge, priorityQueue);
					}
				}
				u.setScanned(true);
				u = priorityQueue.poll();
			}
			/*We have a destination node now with smallest distance*/
			Node source = u.getPathUptoPreviousNode().getNodeList().get(0);
			
			//Check for another destination node with same travel time
			evacuationTime+= u.getTravelTime();
			if(priorityQueue.size()>1)
			{
				double tempTime = u.getTravelTime();
				
				//Queue q = priorityQueue;
				Node secondElem = (Node)priorityQueue.toArray()[1];
				if(!sameTime && secondElem.getTravelTime()==tempTime && secondElem.getNodeType() == Node.DESTINATION)
				{
					if(source == secondElem.getPathUptoPreviousNode().getNodeList().get(0))
						sameTime = true;
				}
			}
			
			//Find the minimum capacity cmin and the edge e where this bottleneck occurs
			int sourceOccupancy = source.getCurrentOccupancy();
			MinimumCapacityAndEdge minCapacityAndEdge = findMinimumCapacityAndEdge(u);
			
			boolean sourceEmpty = false;
			Node nodeToReset = null;
			int groupSize = 0;
			if(sourceOccupancy <= minCapacityAndEdge.getMinCapacity())
			{
				//Source should get empty
				sourceEmpty = true;
				groupSize = sourceOccupancy;
			}
			else
			{
				nodeToReset = minCapacityAndEdge.getNodeToReset();
				groupSize = minCapacityAndEdge.getMinCapacity();
			}
			//Reserve the path and assign the route to a group of size
			//min(cmin, evacuees in source of path found) from the source
			reservePath(u, groupSize);
			tempcount = tempcount + groupSize;
			if(sourceEmpty)
			{
				if(evacueeCount != groupSize)
				{
					resetNodes(source, priorityQueue);
					//Source node becomes a normal node after getting empty
					source.setNodeType(Node.NORMAL);
				}
				else
				{
					//Evacuee count is equal to the group size means this is the last group.
					//Hence, no need to reset since the tree wont be used anymore.
					break;
				}
			}
			else
			{
				Node parent = nodeToReset.getParent();
				resetNodes(nodeToReset, priorityQueue);
				priorityQueue.add(parent);
			}
			Iterator<Node> PQAdditionListIterator = PQAdditionList.iterator();
			while(PQAdditionListIterator.hasNext())
			{
				Node n = PQAdditionListIterator.next();
				n.setScanned(false);
				priorityQueue.add(n);
			}
			PQAdditionList.clear();
			evacueeCount = evacueeCount - groupSize;
			
		}
		System.out.println("Egress Time : " + pathList.get(pathList.size()-1).getArrivalTime().get(pathList.get(pathList.size()-1).getNodeList().size()-1));
		System.out.println("RouteList Size : " + pathList.size());
		System.out.println("Average Evacuation Time : " + 1.0*evacuationTime/tempcount);
		System.out.println("Flag : " + sameTime);
		System.out.println("Avg Hops : " + 1.0*Route.getTotalHops()/pathList.size());
		System.out.println("Max Hops : " + Route.getMaxHops());
		System.out.println("No of Distinct Routes : " + this.getDistinctRoutes().size());
		int maxWaitingTimeAtANode = 0;
		String nodeName;
		double totalWaitingTime = 0;
		int destUsed = 0;
		int nodesUsed = 0;
		for(int i=0;i<graph.getNodeList().size();i++)
		{
			if(graph.getNodeList().get(i).getNoOfPeopleThroughThisNode()==0)
			{
				nodesUsed++;
				if(graph.getNodeList().get(i).getNodeType()==Node.DESTINATION)
					destUsed++;
			}
			totalWaitingTime += graph.getNodeList().get(i).getWaitingTimeAtThisNode();
			if(graph.getNodeList().get(i).getWaitingTimeAtThisNode() > maxWaitingTimeAtANode)
			{
				maxWaitingTimeAtANode = graph.getNodeList().get(i).getWaitingTimeAtThisNode();
				nodeName = graph.getNodeList().get(i).getNodeName();
			}
		}
		System.out.println("Dest Used ; " + nodesUsed);	
		System.out.println("Dest Used ; " + destUsed);
		System.out.println("Max. Waiting Time at a node : " + maxWaitingTimeAtANode);
		System.out.println("Average. Waiting Time at a node : " + totalWaitingTime/graph.getNodeList().size());
	}
	
	public void resetNodes(Node n, PriorityQueue<Node> priorityQueue)
	{
		if(!n.isScanned() && n.getChildList() == null)
		{
			for(int index = 0; index < n.getAdjacencies().size(); index++)
			{
				Edge edge = n.getAdjacencies().get(index);
				Node v;
				if(edge.getSource() == n)
					v = edge.getTarget();
				else
					v = edge.getSource();
				if (v.isScanned() && n.getParent() != v)
				{
					PQAdditionList.add(v);
				}
			}
		
			n.setTravelTime(Double.MAX_VALUE);
			n.setParent(null);
			n.setPathUptoPreviousNode(null);
			priorityQueue.remove(n);
		}
		else
		{
			/*Resetting scanned node */
			if(n.getChildList() != null)
			{
				Iterator<Node> childListIterator = n.getChildList().iterator();
				while(childListIterator.hasNext())
				{
					Node v = childListIterator.next();
					resetNodes(v, priorityQueue);
				}
			}
			if(n.getAdjacentScannedList() != null)
			{
				Iterator<Node> adjacentScannedListIterator = n.getAdjacentScannedList().keySet().iterator();
				while(adjacentScannedListIterator.hasNext())
				{
					Node u = adjacentScannedListIterator.next();
					PQAdditionList.add(u);
					u.getAdjacentScannedList().remove(n);
					n.getAdjacentScannedList().remove(u);
				}
			}
			n.setScanned(false);
			n.setChildList(null);
			n.setParent(null);
			n.setPathUptoPreviousNode(null);
			n.setTravelTime(Double.MAX_VALUE);
			PQAdditionList.remove(n);
		}
	}
	
	/*
	 * This will first reserve path from second node upto last edge
	 * Then it will increase capacity of source at departure time from the source node
	 * Then it will decrease occupancy of source node
	 * Add route to pathList
	 * Display the route
	 */
	public void reservePath(Node destination, int groupSize)
	{
		PathUptoNode pathUptoNode = destination.getPathUptoPreviousNode();
		int noOfNodes = pathUptoNode.getNodeList().size();
		for(int n=0; n<noOfNodes; n++)
		{
			Node tempNode = pathUptoNode.getNodeList().get(n);
			Edge tempEdge = pathUptoNode.getEdgeList().get(n);
			
			int depart = pathUptoNode.getDepartureTime().get(n);
			int edgeTravelTime = (int)Math.ceil(tempEdge.getTravelTime());
			boolean sameFlowDirection = false;
			
			if(tempNode == tempEdge.getSource())
				sameFlowDirection = true;
			//Edge reservation
			int newCapacity = 0;
			
			if(sameFlowDirection)
			{
				newCapacity = tempEdge.getEdgeCapacity().get(depart) - groupSize;
				tempEdge.getEdgeCapacity().set(depart, newCapacity);
			}
			else
			{
				newCapacity = tempEdge.getEdgeCapacity().get(depart + edgeTravelTime) - groupSize;
				tempEdge.getEdgeCapacity().set(depart + edgeTravelTime, newCapacity);
			}
			//For eg : Departure time at 15, travel time = 5, Hence slot 'time' should be 
			//booked at time 15 + time(0,1,2,3,4) = (15,16,17,18,19)
			
			Node currNode = pathUptoNode.getNodeList().get(n);
			currNode.setNoOfPathsThroughThisNode(currNode.getNoOfPathsThroughThisNode() + 1);
			currNode.setNoOfPeopleThroughThisNode(currNode.getNoOfPeopleThroughThisNode() + groupSize);
			
			int currNodeArrival = 0;
			if(n!=0)
				currNodeArrival = (int)currNode.getTravelTime();
			
			int departure = pathUptoNode.getDepartureTime().get(n);
			currNode.setWaitingTimeAtThisNode(departure-currNodeArrival);
			
			for(int i=currNodeArrival;i<departure;i++)
			{
				int newNodeCapacity = tempNode.getNodeCapacityAtTime().get(i) - groupSize;
				tempNode.getNodeCapacityAtTime().set(i, newNodeCapacity);
			}
		}
		
		Node src = destination.getPathUptoPreviousNode().getNodeList().get(0);
		src.setCurrentOccupancy(src.getCurrentOccupancy() - groupSize);
		
		//Add path to pathList
		Route route = new Route();
		route.setRouteId(pathId);
		route.setGroupSize(groupSize);
		route.getArrivalTime().add(0);	//Source node arrival time
		for(int index = 0; index < pathUptoNode.getNodeList().size(); index++)
		{
			Node temp = pathUptoNode.getNodeList().get(index);
			route.getNodeList().add(temp.getNodeName());
			if(index != 0)
				route.getArrivalTime().add((int)Math.ceil(temp.getTravelTime()));
			
			Edge tempEdge = pathUptoNode.getEdgeList().get(index);
			route.getEdgeList().add(tempEdge.getEdgeName());
			
			route.getDepartureTime().add(pathUptoNode.getDepartureTime().get(index));
		}
		route.getNodeList().add(destination.getNodeName());
		route.getArrivalTime().add((int)Math.ceil(destination.getTravelTime()));
		route.getDepartureTime().add(-1);  //Destination departure time
		this.pathList.add(route);
		
		Route.addTotalHops(route.getNodeList().size());
		if(Route.getMaxHops() < route.getNodeList().size())
			Route.setMaxHops(route.getNodeList().size());
		
		if(destination.getTravelTime() > Route.getMaxLength())
			Route.setMaxLength(destination.getTravelTime());
		
		if(runNo==1)
		{
			if(src.getCompareRuns()==null)
			{
				src.setCompareRuns(new HashMap<String, IntPair>());
			}
			if(src.getCompareRuns().get(route.getRouteString()) == null)
			{
				IntPair intpair = new IntPair();
				intpair.setB1(src.getInitialOccupancy());
				intpair.setA1(1);
				src.getCompareRuns().put(route.getRouteString(), intpair);
			}
			else
			{
				IntPair intpair = src.getCompareRuns().get(route.getRouteString());				
				intpair.addA1();
				intpair.setB1(src.getInitialOccupancy());
			}
		}
		else
		{
			if(src.getCompareRuns()==null)
			{
				src.setCompareRuns(new HashMap<String, IntPair>());
			}
			if(src.getCompareRuns().get(route.getRouteString()) == null)
			{
				src.setCompareRuns(new HashMap<String, IntPair>());
				IntPair intpair = new IntPair();
				intpair.setB2(src.getInitialOccupancy());
				intpair.setA2(1);
				src.getCompareRuns().put(route.getRouteString(), intpair);
			}
			else
			{
				IntPair intpair = src.getCompareRuns().get(route.getRouteString());
				intpair.addA2();
				intpair.setB2(src.getInitialOccupancy());
			}
		}
		//route.displayRoute2();
		distinctRoutes.add(route.getRouteString());
		this.pathId++;
	}
	
	
	public MinimumCapacityAndEdge findMinimumCapacityAndEdge(Node destination)
	{
		PathUptoNode pathUptoNode = destination.getPathUptoPreviousNode();
		int noOfNodes = pathUptoNode.getNodeList().size();	
		
		int minCapacity = Integer.MAX_VALUE;
		Edge minCutEdge = null;
		Node nodeToReset = null;
		for(int n=0; n<noOfNodes; n++)
		{
			//Comparing minCapaciy, edge and nextNode
			Node tempNode = pathUptoNode.getNodeList().get(n);
			Edge tempEdge = pathUptoNode.getEdgeList().get(n);
			int depart = pathUptoNode.getDepartureTime().get(n);
			int edgeCapacity = Integer.MAX_VALUE;
			int edgeTravelTime = (int)Math.ceil(tempEdge.getTravelTime());
			int nodeCapacity = Integer.MAX_VALUE;
			boolean sameFlowDirection = false;
			if(tempNode==tempEdge.getSource())
				sameFlowDirection = true;
			
			//For eg : Departure time at 15, travel time = 5, Hence check capacity booked at  
			//slot 'time' for time 15 + time(0,1,2,3,4) = (15,16,17,18,19)
			int newCapacity = 0;
			if(sameFlowDirection)
			{
				newCapacity = tempEdge.getEdgeCapacity().get(depart);
			}
			else
			{
				newCapacity = tempEdge.getEdgeCapacity().get(depart + edgeTravelTime);
			}
			
			if(newCapacity < edgeCapacity)
			{
				edgeCapacity = newCapacity;
			}
			if(n != (noOfNodes - 1))
			{
				tempNode = pathUptoNode.getNodeList().get(n+1);
				int arrival = (int)Math.ceil(tempNode.getTravelTime());
				nodeCapacity = tempNode.getNodeCapacityAtTime().get(arrival);
			}
			if(edgeCapacity < minCapacity && edgeCapacity <= nodeCapacity)
			{
				minCapacity = edgeCapacity;
				minCutEdge = tempEdge;
				if(n == (noOfNodes - 1))
				{
					//nodeToReset is destinationNode
					nodeToReset = destination;
				}
				else
				{
					nodeToReset = tempNode;
				}
			}
			else if(nodeCapacity < minCapacity && nodeCapacity < edgeCapacity)
			{
				minCapacity = nodeCapacity;
				minCutEdge = tempEdge;
				nodeToReset = tempNode;
			}
		}
		MinimumCapacityAndEdge minimumCapacityAndEdge = 
				new MinimumCapacityAndEdge(minCapacity, minCutEdge, nodeToReset);
		return minimumCapacityAndEdge;
	}
	
	public void simpleDijkstra(Node u, Node v, Edge edge, PriorityQueue<Node> priorityQueue)
	{
		double departureTimeFromU;
		if(edge.getSource() == u)
			departureTimeFromU = u.getTravelTime();
		else
			departureTimeFromU = u.getTravelTime() + edge.getTravelTime(); //means we will reach source after travel time
		/* Time instances to add to an edge
		 * We add at least that many time instances as the travel time 
		 * of node u
		*/

		double timeInstancesToAdd = departureTimeFromU - edge.getEdgeCapacity().size() + 2;

		
		for(int i = 0; i < timeInstancesToAdd; i++)
			edge.addEdgeCapacity();
		
		//while the capacity in first section of this edge is not available
		//we will wait here only
		int delay = 0;
		while(edge.getEdgeCapacity().get((int)Math.ceil(departureTimeFromU)) <= 0)
		{
			delay++;
			departureTimeFromU++;
			if (edge.getEdgeCapacity().size() <= departureTimeFromU)
				edge.addEdgeCapacity();
		}

		//Adding Time instances for u
		timeInstancesToAdd = u.getTravelTime() + delay - 
				u.getNodeCapacityAtTime().size() + 1;
		for(int i = 0; i < timeInstancesToAdd; i++)
			u.getNodeCapacityAtTime().add(u.getMaxCapacity());
		
		double distanceToVThroughU = u.getTravelTime() + delay + edge.getTravelTime();

		/* Time instances to add to far vertex v
		 * We add at least that many time instances as the travel time 
		 * to node v
		*/
		timeInstancesToAdd = distanceToVThroughU - v.getNodeCapacityAtTime().size() + 2;

		for(int i = 0; i < timeInstancesToAdd; i++)
			v.getNodeCapacityAtTime().add(v.getMaxCapacity());

		//Capacity should be available at both the edge and at the vertex 
		while((v.getNodeCapacityAtTime().get((int)Math.ceil(distanceToVThroughU)) <= 0)
				|| edge.getEdgeCapacity().get((int)Math.ceil(departureTimeFromU)) <= 0)
		{
			delay++;
			distanceToVThroughU++;
			departureTimeFromU++;
			//Add time instance to node v
			v.getNodeCapacityAtTime().add(v.getMaxCapacity());
			u.getNodeCapacityAtTime().add(u.getMaxCapacity());
			//Add time instances to edge uv
			while(edge.getEdgeCapacity().size() <=
					(departureTimeFromU + 1))
			{
				edge.addEdgeCapacity();
			}
		}

		if(distanceToVThroughU < v.getTravelTime())
		{

			if(v.getParent() != null)
			{
				//v has Parent
				v.getParent().removeChild(v);
			}
			v.setParent(u);
			u.addChild(v);

			PathUptoNode pathUptoPreviousNode = null;
			if(u.getPathUptoPreviousNode() == null)
			{
				//u is source node
				pathUptoPreviousNode = new PathUptoNode();
			}
			else
			{
				pathUptoPreviousNode = new PathUptoNode(u.getPathUptoPreviousNode());
			}
			pathUptoPreviousNode.add(u, edge, (int)Math.ceil(u.getTravelTime() + delay));
			v.setPathUptoPreviousNode(pathUptoPreviousNode);
			v.setTravelTime(distanceToVThroughU);
			if(priorityQueue.contains(v))
				priorityQueue.remove(v);
			priorityQueue.add(v);
			/* Time instances to add to an edge
			 * We add at least that many time instances as the travel time 
			 * of node v at end
			*/
			timeInstancesToAdd = distanceToVThroughU - 
					edge.getEdgeCapacity().size() + 2;

			for(int i = 0; i < timeInstancesToAdd; i++)
				edge.addEdgeCapacity();
		}
	}
	
	public void displayNodeEdgeStats()
	{
		FileWriter writer = null;
		try
		{
		    writer = new FileWriter("/Users/MLGupta/Documents/ModifiedNodeData101.csv");
		    writer.append("NodeName,NoOfPaths,NoOfPeople,WaitingTime\n");
			for(int i=0;i<graph.getNodeList().size();i++)
			{
				Node n = graph.getNodeList().get(i);
				String str = "";
				str+=n.getNodeName() + "," + n.getNoOfPathsThroughThisNode() + "," + n.getNoOfPeopleThroughThisNode() + "," + n.getWaitingTimeAtThisNode() + "\n";
				writer.write(str);
				//System.out.println(str);
			}
			writer.close();
		}
		catch(Exception e)
		{
			System.out.println(e.getMessage());
		}
		
		try
		{
		    writer = new FileWriter("/Users/MLGupta/Documents/ModifiedRouteList101.csv");
		    writer.append("RouteList\n");
			for (Iterator<String> iterator = this.distinctRoutes.iterator(); iterator.hasNext();) {
				String route = (String) iterator.next();
				writer.write(route + "\n");
			}
			writer.close();
		}
		catch(Exception e)
		{
			System.out.println(e.getMessage());
		}
	}
	
	public void changeNodeCap(String nodename, int cap)
	{
		Node node = this.getNode(nodename);
		node.setOccupancyBefore(node.getInitialOccupancy());
		node.setInitialOccupancy(cap);
		node.setCurrentOccupancy(cap);
		if(cap>0)
			node.setNodeType(Node.SOURCE);
	}
	
	public void clearNodeEdgeData()
	{
		for(int i=0;i<graph.getNodeList().size();i++)
		{
			
			Node n = graph.getNodeList().get(i);
			n.setChildList(null);
			n.setParent(null);
			n.setPathUptoPreviousNode(null);
			n.setScanned(false);
			n.setAdjacentScannedList(null);
			if(n.getInitialOccupancy() > 0)
				n.setTravelTime(0);
			else
				n.setTravelTime(Double.MAX_VALUE);
			n.setNoOfPathsThroughThisNode(0);
			n.setNoOfPeopleThroughThisNode(0);
			n.setNodeCapacityAtTime(null);
			ArrayList<Integer> nodeCapacityAtTime = new ArrayList<Integer>();
			nodeCapacityAtTime.add(n.getMaxCapacity());
			n.setNodeCapacityAtTime(nodeCapacityAtTime);
		}
		
		for(int i=0;i<graph.getEdgeList().size();i++)
		{
			Edge e = graph.getEdgeList().get(i);
			e.setEdgeMaxCapacityTimeInstance(null);
			e.setEdgeSourceBlocked(null);
			e.setEdgeTargetBlocked(null);
			e.setEdgeUsage(0);
			e.setTempEdgeCapacity(null);
			e.setEdgeCapacity(null);
			e.setEdgeCapacity(new ArrayList<Integer>());
			//For each section of edge, initially(t=0) capacity is its maximum
			for (int j = 0; j < e.getTravelTime(); j++)
			{
				e.getEdgeCapacity().add(e.getMaxIntakeCapacity());
			}
		}
	}
	
	public void findResults()
	{
		
		int nodeIncCountRouteDec = 0, nodeIncCountRouteInc=0, nodeIncCountRouteSame=0,nodeIncCountRouteIncDec=0;
		int nodeDecCountRouteDec = 0, nodeDecCountRouteInc=0, nodeDecCountRouteSame=0,nodeDecCountRouteIncDec=0;
		int nodeSameCountRouteDec = 0, nodeSameCountRouteInc=0, nodeSameCountRouteSame=0,nodeSameCountRouteIncDec=0;
		for(int i=0;i<graph.getNodeList().size();i++)
		{
			int peopleIncDistRoutesInc=0, peopleDecDistRoutesInc=0, peopleSameDistRoutesInc=0;
			int peopleIncDistRoutesDec=0, peopleDecDistRoutesDec=0, peopleSameDistRoutesDec=0;
			int peopleIncDistRoutesSame=0, peopleDecDistRoutesSame=0, peopleSameDistRoutesSame=0;
			Node n = graph.getNodeList().get(i);
			if(n.getCompareRuns()!=null)
			{
				//src node
				Object [] routesFromN = n.getCompareRuns().keySet().toArray();
				int c1 = 0, c2=0;
				if(n.getInitialOccupancy() > n.getOccupancyBefore())
				{
					for(int j=0;j<routesFromN.length;j++)
					{
						IntPair intpair = n.getCompareRuns().get((String)routesFromN[j]);
						if(intpair.getA1()==0)
						{
							//route exists in A2
							peopleIncDistRoutesInc++;
						}
						else if(intpair.getA2()==0)
						{
							//route exists in A2
							peopleIncDistRoutesDec++;
						}
						else
						{
							peopleIncDistRoutesSame++;
						}
					}
					if(peopleIncDistRoutesInc > 0  && peopleIncDistRoutesDec > 0)
					{
						nodeIncCountRouteIncDec++;
					}
					else if(peopleIncDistRoutesInc > 0)
					{
						nodeIncCountRouteInc++;
					}
					else if(peopleIncDistRoutesDec > 0)
					{
						nodeIncCountRouteDec++;
					}
					else
					{
						nodeIncCountRouteSame++;
					}
				}
				else if(n.getInitialOccupancy() < n.getOccupancyBefore())
				{
					for(int j=0;j<routesFromN.length;j++)
					{
						IntPair intpair = n.getCompareRuns().get((String)routesFromN[j]);
						if(intpair.getA1()==0)
						{
							//route exists in A2
							peopleDecDistRoutesInc++;
						}
						else if(intpair.getA2()==0)
						{
							//route exists in A2
							peopleDecDistRoutesDec++;
						}
						else
						{
							peopleDecDistRoutesSame++;
						}
					}
					if(peopleDecDistRoutesInc > 0  && peopleDecDistRoutesDec > 0)
					{
						nodeDecCountRouteIncDec++;
					}
					else if(peopleDecDistRoutesInc > 0)
					{
						nodeDecCountRouteInc++;
					}
					else if(peopleDecDistRoutesDec > 0)
					{
						nodeDecCountRouteDec++;
					}
					else
					{
						nodeDecCountRouteSame++;
					}
				}
				else
				{
					for(int j=0;j<routesFromN.length;j++)
					{
						IntPair intpair = n.getCompareRuns().get((String)routesFromN[j]);
						if(intpair.getA1()==0)
						{
							//route exists in A2
							peopleSameDistRoutesInc++;
						}
						else if(intpair.getA2()==0)
						{
							//route exists in A2
							peopleSameDistRoutesDec++;
						}
						else
						{
							peopleSameDistRoutesSame++;
						}
					}
					if(peopleSameDistRoutesInc > 0  && peopleSameDistRoutesDec > 0)
					{
						nodeSameCountRouteIncDec++;
					}
					else if(peopleSameDistRoutesInc > 0)
					{
						nodeSameCountRouteInc++;
					}
					else if(peopleSameDistRoutesDec > 0)
					{
						nodeSameCountRouteDec++;
					}
					else
					{
						nodeSameCountRouteSame++;
					}
				}
			}
		}
		
		System.out.println("Nodes- People Inc - Routes Inc : " + nodeIncCountRouteInc);
		System.out.println("Nodes- People Inc - Routes Dec : " + nodeIncCountRouteDec);
		System.out.println("Nodes- People Inc - Routes Same : " + nodeIncCountRouteSame);
		System.out.println("Nodes- People Inc - Routes Change(Count Same) : " + nodeIncCountRouteIncDec);
		System.out.println("Nodes- People Dec - Routes Inc : " + nodeDecCountRouteInc);
		System.out.println("Nodes- People Dec - Routes Dec : " + nodeDecCountRouteDec);
		System.out.println("Nodes- People Dec - Routes Same : " + nodeDecCountRouteSame);
		System.out.println("Nodes- People Dec - Routes Change(Count Same) : " + nodeDecCountRouteIncDec);
		System.out.println("Nodes- People Same - Routes Inc : " + nodeSameCountRouteInc);
		System.out.println("Nodes- People Same - Routes Dec : " + nodeSameCountRouteDec);
		System.out.println("Nodes- People Same - Routes Same : " + nodeSameCountRouteSame);
		System.out.println("Nodes- People Same - Routes Change(Count Same) : " + nodeSameCountRouteIncDec);

	}
}